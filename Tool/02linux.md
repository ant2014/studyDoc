#Linux常用命令
##0、Linux的引导过程
系统加点以后，首先进行硬件自检，然后是bootloader对系统的初始化，加载内核。内核被加载到内存中后，就开始执行了。一旦内核启动运行，对硬件的检测就会决定需要对哪些设备驱动程序进行初始化。从这里开始，内核就能够挂在根文件系统，内核挂载了跟文件系统，并已初始化所有的设备驱动程序和数据结构后，就通过启动一个叫init的用户级程序，完成引导进程。
init进程是系统启动后的第一个用户进程，所以它的pid始终为1。init进程上来首先做的事是去读取/etc/inittab文件中的initdefault id的值，这个值称为默认运行级别，它决定了系统刚启动是出于什么级别。不同级别具有不同的功能。

不同的运行级定义如下： 

* 0 - 停机（千万别把initdefault设置为0，否则系统永远无法启动）
* 1 - 单用户模式
* 2 - 多用户，没有 NFS
* 3 - 完全多用户模式(标准的运行级)
* 4 – 系统保留的
* 5 - X11 （x window)
* 6 - 重新启动 （千万不要把initdefault 设置为6，否则将一直在重启 ）

##1、命令基本格式与文件处理命令
`[root@localhost ~]#` [账户@主机名 当前所在位置] #(表示登陆用户为管理员，普通用户的命令提示符为$)  
~家目录，初始登陆位置，管理员的家目录在/root下，普通用户的家目录在/home/${username}

###命令格式
命令 [选项] [参数]  
注意：

1. 大多数命令都是这个格式，但不排除有个别特殊命令不遵循这个格式
2. 可以简写，例如-a等于--all，并且当有多个选项时，可以连写

###文件命令：查询目录中的内容
ls [选项] [文件或目录]  
选项：

* -a 显示所有文件，包括隐藏文件（以.开头，隐藏文件并不是为了真的藏起来，而是系统文件隐藏自己防止误操作）
* -l 显示详细信息
* -d 查看目录属性，查看目录本身，而不是查看该目录下面的子文件
* -h 人性化显示文件大小，human，所有文件大小的都支持-h参数
* -i 显示inode，每个文件都有一个id号，系统查找的时候，就是通过这个id号来判断

###ll结果分析
![ls图片](http://7xjao4.com1.z0.glb.clouddn.com/B8A9D840-AEFB-4370-9FEF-B83C1ABEAA84.png)
-rwxr--r--  
含义：

* - 第一位，代表文件类型，（-文件，d目录，l软链接文件），Linux中不是靠扩展名来区分文件的，Linux中没有扩展名这个概念，文件类型只有7种（常见的如上述三种），相比下windows中的扩展名则有数不清多种，如.doc .ppt .exe .txt
* r 度 w 写 r 执行
* 三组分别代表u所有者 g所属组 o其他人

之后的1代表，引用计数的个数，

root root 代表所有者和所属组

文件的大小

文件的最后修改时间

文件名

### 目录处理命令
普通文件是用来保存数据的，而目录是来保存文件的
#### 建立目录mkdir   
mkdir -p [目录名]  // make directory
-p 递归创建

#### 切换目录 cd
cd [目录] //change directory
cd ~ / cd 回到家目录
cd - 进入上次目录，多次执行
cd . 进入当前目录
cd .. 进入上级目录

### 查询当前所在目录 pwd
pwd // print working directory

### 删除空目录 rmdir
rmdir [目录名]		// remove empty directories
只能删除空目录，故不常用，常用下一条命令

### 删除文件或目录 rm
rm -rf [文件或目录]	// remove
选项：
	
* -r 删除目录，recursive 递归
* -f 强制

Linux图形界面有回收站，但是纯命令模式下，没有回收站，删了就真没有了

### 复制文件或目录 cp
cp [选项] [原文件或目录] [目标目录]	// copy
选项：

* -r 复制目录
* -p 连带文件属性复制，默认复制过去的文件的时间是执行复制动作的时间
* -d 若源文件是链接文件，则复制链接属性
* -a 相当于-pdr

若目标为目录，则原文件名复制，若目标为目录下的文件名，则复制过去并改名

### 文件或目录剪切或改名 mv
mv [原文件或目录] [目标目录]	//move  
如果原文件和目标文件不在一个目录下就是剪切，如果在一个目录下，就是改名

### Linux常用目录的作用

* / 根目录
* /bin 命令保存目录，普通用户就可以读取的命令。根目录下的bin和sbin，/usr下的bin和sbin，这4个目录都是用来保存系统命令的。区别是2个sbin目录只有root用户能执行。
* /usr 系统软件资源目录
* /var 系统相关文档内容
* /boot 启动目录，启动相关文件
* /dev 设备文件保存目录
* /etc	配置文件保存目录
* /home 普通用户的家目录
* /root 超级用户的家目录
* /lib 系统函数库保存目录，并不是把所有的功能都写到了系统中，而是把部分功能写成了一个个的库
* /mnt 系统挂载目录，三个空目录作为外接存储设备的盘符，mnt挂载优盘
* /media 挂载目录，挂载光盘
* /misc 挂载目录，挂载磁盘
* /proc /sys 这两个目录保存的是内存的挂载点，内存的盘符，不能直接操作
* /tmp 临时目录，临时数据可以放在这里

文件请遵循规范存放，可以在家目录和tmp目录下随便存放。


### 文件处理命令

### 链接命名
ln -s [原文件] [目标文件]	//link
用来生成链接文件，有软链接和硬链接之分

选项：

* -s 创建软链接

硬链接：分区主要做两件事，一是划分block存储块，二是创建分区表。查找文件时，先去分区表中查找文件所在的具体的block块，然后再访问block块。硬链接，即两个不同的名字，但都指向相同的分区表的字段，再指向相同的block存储空间。如果我们删掉其中的一个名字，则文件还可以通过另外一个名字正常打开。所以，硬链接可以理解为一个教室有两个不同的门，都可以正常访问。

硬链接的特征：

1. 拥有相同的i节点和存储block块，可以看做是同一个文件。
2. 可通过i节点识别
3. 不能跨分区
4. 不能针对目录使用，只有文件可以创建硬链接

实例：
ln /root/a.cfg /tmp/b.hard.cfg
ll命令查看，这两个文件的信息完全一样，变化的地方仅是，引用计数都加了1  
现在我们修改a.cfg文件，会发现b.hard.cfg的内容同步变化了
我们删除a.cfg，b.hard.cfg仍然可以正常使用，引用计数会减一

ls -i /root/a.cfg /tmp/b.hard.cfg
可以看出，二者的i节点号是一样的，可以从这里识别他们俩，也只能从这里识别他们

不建议使用硬链接，除了可以通过i节点识别外，我们很难发现它是不是硬链接，而且硬链接的限制很多，不能跨分区，不能针对目录


软链接的特征：

1. 类似windows的快捷方式，几乎一样的特性
2. 软链接拥有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点，并没有实际的文件数据
3. lrwxrwxrwx，l标明了自己的身份为软链接，软链接的权限均为rwxrwxrwx
4. 修改任意一个文件，另一个都跟着变
5. 删除原文件，软链接不可用

注意，软链接的原文件如果是相对路径，必须和目标文件在同一个文件下面，否则会找不到，所以软链接的原文件最好写绝对路径

echo 123 >> /tmp/a，可以将字符添加到原文件的尾部


 
##2、文件搜索命令
###2.1 文件搜索命令 locate
在后台数据库中按文件名搜索，最大的好处是搜索速度很快，但是，如果我们新建一个文件，然后马上locate它，你会发现，搜不到。原因是，locate并不是直接在系统中搜索，而是在/var/lib/mlocate数据库中进行搜索，但是这个数据库文件并不是实时更新的，而是每天更新一次，可以执行updatedb命令强制更新  
locate的另一个缺点是，只能按照文件名去搜索  
locate 文件名

locate是按照/etc/updatedb.conf配置文件来搜索的

* PRUNE_BIND_MOUNTS="yes"	//开启搜索限制，表示下列配置生效
* PRUNEFS = 	//搜索时不搜索的文件系统
* PRUNENAMES = //搜索时不搜索的文件类型
* PRUNEPATHS = //搜索时不搜索的路径

注意whereis和which也遵循这个配置文件的规则

###2.2 文件搜索命令 find
find [搜索范围] [搜索条件]
find / -name install.log
避免把搜索范围设置的过大，会非常耗费系统资源
find默认是在系统中搜索完全符合文件名的的文件。如果需要模糊匹配，需要使用通配符

Linux中的主要通配符
* 匹配任意内容
？匹配任意一个字符
[]匹配任意一个中括号内的字符

find /root -name "install.log*"
find /root -iname install.log  //文件名不区分大小写
find /root -user root //按照所有者搜索
find /root -nouser	//查找没有所有者的文件
find /var/log -mtime +10	//查找10天前修改的文件
-10 10天内
10 10天当天
+10 10天前

atime 文件访问时间
ctime 改变文件属性的时间
mtime 改变文件内容的时间

find /root -size 25k	//查找文件大小是25k的文件，k小写，M大写
+25k	大于25k
-25k	小于25k

find /root -inum 26224	//查找i节点号为26224的文件

find /root -size +20k -a -size -50k	//查找大于20k并小于50k的文件
-a and 逻辑与，两个条件都满足
-o or 逻辑或，两个条件满足一个即可

find /root -size +20k -a -size -50k -exec ls -lh {} \;//查找大于20k并小于50k的文件，并显示详细信息
-exec/-ok 命令 {} \; 对搜索结果执行操作，这是固定格式，中间的命令必须是能处理第一个结果的命令


###2.3 命令搜索命令 whereis和which
whereis 命令名
搜索命令所在路径及帮助文档所在位置
选项：
	
* -b 只查找可执行文件
* -m 只查找帮助文件

whoami
whatis ls

which 文件名
搜索命令所在的路径及别名

whereis 可以看到命令所在的位置和帮助文档
which可以看到命令的别名

通过whereis和which看到的都是外部安装的，外来命令，cd命令是shell内置的命令，他俩都找不到

PATH环境变量
定义了系统搜索命令的路径
echo $PATH


###2.4 字符串搜索命令 grep
grep [选项] 字符串 文件名
在文件当中匹配符合条件的字符串
选项：

* -i 忽略大小写
* -v 排除指定字符串，取反，搜索不包含字符串


###2.5 find命令和grep命令的区别
find命令：在系统中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配  
grep命令：在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式进行匹配，正则表达式是包含匹配

##3、帮助命令
man 命令 //获取指定命令的帮助，man是manual的缩写，等同于whatis命令
man -f passwd		//可以查看命令所有等级的帮助信息
![man -f passwd](http://7xjao4.com1.z0.glb.clouddn.com/test-1E0C0A62-398E-42D0-8592-5AD7894D2EE6.png)
可以看到这个命令有两个等级的帮助文件
man 5 passwd		//查看5级命令的帮助文件，如果有多个等级，而你又没有指定等级号，则默认打开最小等级的命令
man 8 ifconfig	//ifconfig是8级的命令，管理员的命令，一般用户不能调用

man -k passwd		//查找到所有帮助文档中有“passwd”关键字的
apropos passwd  //等同于man -k

命令 --help	//获取命令选项的帮助，部分已经翻译成中文了

为什么叫shell，shell是包裹内核的壳，内核只能执行01的机器指令，shell要将字符指令翻译为机器指令，再传给内核，说白了就是用户和计算机内核交互的接口。

确定是否是内部命令
Linux中有些命令是Linux中自带的，有些是别人写好装到Linux中的，如何区分命令是否是自带的呢？
![](http://7xjao4.com1.z0.glb.clouddn.com/test-0A8E8FB7-E89B-4CF3-8A1E-5385C3CBBC2B.png)
如上图所示，如果whereis后没有命令的位置，则这个命令是内核自带的，cd就是典型的内核自带的命令。

man内核命令如man cd不能直接得到cd的详细说明，可以使用help来专门获取内部命令的帮助，help cd，help不能获取外部命令的帮助。


info命令是个巨大的帮助文档，不常用

##4、压缩命令
常用压缩格式.zip .gz .bz2 .tar.gz .tar.bz2
Linux不需要扩展名，但是对于压缩文件，我们还是需要写扩展名，为了方便识别出来这个是压缩文件

.zip压缩格式，Linux和Windows中是通用的
zip 压缩文件名 源文件	//压缩文件

zip -r 压缩文件名 源目录	//压缩目录

uzip 压缩文件	//解压缩文件

.gz压缩格式
gzip 源文件  //压缩为.gz格式的压缩文件，源文件会消失

gzip -c 源文件 > 压缩文件  //压缩为.gz格式，源文件保留，>是重定向，将前面的结果写到后面去
例如gzip -c cangls > cangls.gz

gzip -r 目录  //压缩目录下的所有子文件，但是不能压缩目录

gzip -d 压缩文件	//解压缩文件

gunzip 压缩文件	//解压缩文件

.tar.gz
目录不能压缩，那么可以先使用tar命令将其打包为一个文件
tar -cvf 打包文件名 源文件
选项：

* -c 打包
* -v 显示过程
* -f 指定打包后的文件名

例如：tar -cvf longls.tar longls

解打包的方法
tar -xvf 打包文件名	//-x 解打包
例如：tar -xvf longls.tar

用起来很麻烦
.tar.gz是先打包为.tar格式，再压缩为.gz格式
tar -zcvf 压缩文件名.tar.gz 源文件
tar -jcvf 压缩文件名.tar.bz2 源文件

tar -zxvf 压缩文件名.tar.gz
tar -jxvf 压缩文件名.tar.bz2

tar -jxvf longls.tar.bz2 -c /tmp/		//指定解压缩的位置
tar -jcvf longls.tar.bz2 longls1 longls2  //压缩多个文件在一起
tar -jzvf longls.tar.bz2 //只查看其中的目录，而不真解压


.bz2压缩格式
bzip2 源文件	//压缩为.bz2格式，不保留源文件
bzip2 -k 源文件	//压缩之后保留源文件
注意bzip2命令不能压缩目录

bzip2 -d 压缩文件	//解压缩，-k保留压缩文件
bunzip2 压缩文件	//解压缩，-k保留压缩文件


##5、关机与重启命令
shutdown 命令
shutdown [选项] 时间
选项：
	
* -c 取消前一个关机命令
* -h 关机
* -r 重启

时间可以写now或05:30，但是如果直接写时间会中断终端的操作，无法再输入别的命令，ctrl+c退出，执行shutdown -r 05:30 &，添加一个后台符，放到后台执行

halt

poweroff

init 0
这三个命令不会像shutdown一样在关机时正确保存状态，而是直接关闭，所以不建议用

reboot，init 6重启命令，reboot相对安全

系统运行级别

* 0 关机
* 1 单用户
* 2 不完全多用户，不含NFS服务
* 3 完全多用户
* 4 未分配
* 5 图形界面
* 6 重启

init 0，init是调用的意思，即调用0级别

runlevel	//显示上次的级别和当前级别

修改系统启动后的默认运行级别
cat /etc/inittab

退出登录logout，而不是直接关闭xshell，直接关闭，用户还卡在那里
 
##6、其他常用命令
tail命令是按照要求将指定文件的最后部分输出，如果该文档有更新，则tail会自动刷新，确保你看到的是最新的内容。
1、tail -f filename
说明：监视filename文件的尾部内容（默认10行，相当于添加参数 -n 10），刷新显示在屏幕上。退出，按下CTRL+C。

2、tail -n 20 filename
说明：显示filename最后20行。
相反的有head，只显示前面几行cat 从第一行开始显示文档内容

##7、其他常用目录
init.d中存放的是一些脚本，一般是linux以rpm包安装时设定的一些服务的启动脚本。执行这些脚本可以用来启动、停止、重启这些服务。


##7、Shell基础
##8、软件安装
Linux下源码的编译安装一般分为三个步骤：配置configure、编译make、安装make install  
configure --prefix是用来指定安装目录，类似Windows中指定软件的安装目录，如果不指定prefix，则可执行文件默认放在/usr/local/bin，库文件默认放在/usr/local/bin，配置文件默认放在/usr/local/etc，其他资源文件默认放在/usr/local/share。如果你要卸载这个程序，需要在原来的make目录下使用make uninstall，要么就去上述目录中将相关的文件逐个手工删除。指定prefix后，该软件的所有文件都将被复制到这个目录，直接删除该目录就够了。所以说为了防止软件复制到多个目录下难以维护，最好指定该目录。
使用--prefix的另一个好处是卸载软件或移植软件很方便。卸载只需删除该目录，就可以把软件卸载干净。移植软件只需要拷贝整个目录到另外一台相同系统的机器即可。
